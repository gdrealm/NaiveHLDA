{"id":"3DE9443C-6B5E-4889-9818-51C71064CC86","title":"A higher-order approach to codesign - 27659","abstractText":"Current computing architectures are moving increasingly towards\nheterogeneity, as physical limitations of scale demand a\nbifurcation of optimisation techniques between reducing latency and\nincreasing throughput. In the past, the amount of heterogeneity in\ndevices tended to be limited, therefore RTL were largely suitable for for\nhardware design. However, recently there has been a surge\nof industrial interest in hybrid programmable hardware-software systems.\nFor example, Xilinx has recently launched the\nZynq platform which combines a multicore ARM processor with programmable\nlogic. This development thrusts the question\nof design for such hybrid systems, requiring different programming\nmethodologies, into the foreground.\n\nIn general, as architectures move away from the conventional CPU and RAM\n(von Neumann) model, the task of devising\nprogramming models for them falls mostly with their designers, who are\nusually engineers rather than programming\nlanguage experts. As a result we are witnessing a flurry of\narchitecture-specific languages (ASL), reminiscent of the early\ndays of computation when each computer came with its own operating system,\nprogramming language, etc. Whereas ASLs\nare unavoidable, good programming methodology recommends that they should\nbe used primarily for the development of\nsystem-level infrastructure. The application-level, algorithmic\nprogramming should happen as much as possible in portable,\nmachine-independent languages. These lessons are very well known in the\nprogramming community and this knowledge\ncan be profitably used in electronic design. We aim to address this\nproblem.\n\nThe challenge of heterogeneous codesign is both quantitative and\nqualitative. A program has components that must be\ncompiled into the FPGA fabric and others to be compiled for the CPU. The\nreasons are either efficiency (certain\narchitectures are better at running certain types or code) or physical\nconstraints (interactions with other components in a\ncomplex design, availability of IP cores, drivers or libraries). But a\nprogram may also have components which can be\ncompiled to either architecture or both. A choice must be made and it is\nreasonable for this choice to be also motivated by\nefficiency.\n\nIn this proposal we will combine and unify the way type systems in\nhigher-level languages specify and solve qualitative\n(hard) constraints with quantitative optimisation techniques.\nSpecifically, we will investigate the optimization of memory\nsubsystems to support parallel access, by combining knowledge of memory\naccess patterns from the code, resulting in\nhighly efficient programmable memory controllers. In addition, we will\noptimize the allocation of precision within a combined\nhardware/software system in order to achieve an accuracy specification\nwhile taking into account the capability and cost\nimplications of the programmable hardware and native data types supported\nin the software. This combined approach can\nwork both at the source code level (program transformations motivated by\nunderlying cost models) and at the synthesisedmachine code and HDL level\n(pipelined optimisations, etc). We will use a &quot;game semantic&quot; model,\nalready successfully\napplied to hardware synthesis from higher order languages, to establish\nthe correctness properties of the type system and\nto drive the compilation process.","grantUrl":"http://gtr.rcuk.ac.uk/projects?ref=EP/K015214/1","grantId":"EP/K015214/1","fundValue":"274300","fundStart":"2013-06-17","fundEnd":"2016-12-16","funder":"EPSRC","impactText":"","person":"Dan R Ghica","coPersons":[],"organisation":"University of Birmingham","findingsText":" This research is ONGOING. We are meeting our original objectives TO DATE. This research is ONGOING. We are meeting our original objectives TO DATE. Digital/Communication/Information Technologies (including Software),Electronics","dataset":"gtr"}