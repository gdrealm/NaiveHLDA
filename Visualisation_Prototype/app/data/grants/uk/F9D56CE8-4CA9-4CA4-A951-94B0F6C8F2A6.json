{"id":"F9D56CE8-4CA9-4CA4-A951-94B0F6C8F2A6","title":"Property Testing","abstractText":"Computer storage, such as hard drives and RAM, is rapidly dropping inprice. One implication of this is that many software applications arefaced with ever growing data sets to deal with as input. Neithercomputational power nor communication bandwidth seem to be able to copewith this increase in data in the foreseeable future.There are two immediate problems when we want to run any kind ofapplication on a huge input. Firstly, the data might be stored on aremote server with relatively low communication bandwidth. In this caseeven only reading the entire input is infeasible, let alone processing it. Secondly, what is considered to be ``efficient'' these days may not be fast enough in real-world terms, namely algorithms with arunning time that is polynomial in the size of the input.Parts of the Theoretical Computer Science community are investigating whatis referred to as property testing, which is about determiningwhether an input (for ease of discussion typically abstracted as some kindof combinatorial structure like a matrix, a graph, a function, or astring) has some specified property or not, whilst looking at only a smallfraction of the actual input. Example: As a concrete example, consider the following. Suppose youare given a (very long) string S as input, and wish to determine whetherS is covered by a pattern P. More specifically, an algorithm for thistask is given S, and the required output would be ``yes'' if there exists a frequently occurring pattern P (P is not part of the input itself, and thus not known to the algorithm). This type of question is relevant to manyreal-world situations (databases, telecommunications, search engines). Another question might be if there is some number of patterns (possibly allowing for slight variations thereof) that cover much of the input. There of course exist exact polynomial-time algorithms for this task, but one may be happy with an approximate answer, or one may want to use an approximate answer to merely decide whether or not to spend time and resources to actually run an exact algorithm.The question related to how much of the input needs to be looked at iscommonly referred to as query complexity. This measure relates tothe communication bandwidth issue outlined above. Another issue ofimportance is of course that of the running time complexity of thecorresponding testing algorithms. In many cases, it is going to be afairly easily determined and expressed function in the query complexity(or, more precisely, in the specified distance parameter; more aboutthis later), but this is by no means always the case. Regardless, almostall property testing algorithms fitting this framework have querycomplexity and running time that is sub-linear in the size of the input,again, ideally, independent of the input size, but sometimes only barelybelow linear.In some sense, property testing is to decision problems what the class ofapproximation algorithms are to optimisation problems. There is onenotable difference, however. In property testing, unlike approximationalgorithms, one is not necessarily considering hard problems, as inNP-hard, but problems where exact, polynomial-time decision algorithmsare already known; consider for instance testing for bipartiteness, whichis, of course, trivially decidable in linear time. There are exceptionsto this general rule, however; see for instance [FM06] where theauthors look at isomorphy between graphs.The connection to the world of approximation algorithms is even closer. Avery interesting, relatively new research direction is to marry sub-lineartesting","grantUrl":"http://gtr.rcuk.ac.uk/projects?ref=EP/E029124/1","grantId":"EP/E029124/1","fundValue":"137237","fundStart":"2007-10-01","fundEnd":"2011-03-31","funder":"EPSRC","impactText":"","person":"Thomas  Friedetzky","coPersons":[],"organisation":"Durham University","findingsText":"","dataset":"gtr"}