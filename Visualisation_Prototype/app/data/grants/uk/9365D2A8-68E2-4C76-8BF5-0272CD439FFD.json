{"id":"9365D2A8-68E2-4C76-8BF5-0272CD439FFD","title":"LACE: Lifetime-Aware Collection","abstractText":"The growing use of object-oriented languages like Java and C# in substantial applications of commercial import has made automatic dynamic memory management, or 'garbage collection' (GC), more important economically than ever before. GC allows programs to recycle unused memory automatically, without error-prone programmer intervention. Significant research challenges remain in this area as new environments - from multi-processor servers to hand-held devices - push state-of-the-art collectors to their limits in terms of scalability and responsiveness. Although today's state of the art collectors can meet users' throughput and pause time requirements in heaps of up to many hundred megabytes, current techniques will not scale to the tens of gigabytes heaps that Java virtual machine vendors expect their customers to demand in the near future.Much GC effort is, in a sense, wasted. Rather than reclaiming memory directly (which is what the programmer wants), GC expends effort on preventing the premature and unsafe reclamation of space used by live objects. It has long been known that programs' 'object demographics' are not random. Rather objects are allocated, interact and die in particular patterns. We believe that understanding and exploiting this regularity is the key to the next generation of program-directed memory management. In order to reduce the cost of discovering live objects ('tracing'), GC must concentrate effort on those regions of the heap in which few objects are live.Our vision is for a Lifetime-Aware (LA) GC framework that takes advantage of predictable program behaviour in order to collect only regions of the heap in which we expect the vast majority of objects to be dead. Our preliminary research shows that the number of distinct behaviour patterns are small enough to be mapped onto a region-based memory manager such as Beltway. LA is a new paradigm for allocation and collection. First, it never attempts to reclaim an object before its estimated death-time, whereas conventional 'generational' collectors process even the very newest objects although they are almost certain to be live. Second, long-lived objects must be examined (copied) at least once by a generational collector, but LA collection avoids touching them until they are expected to be dead. Third, to reclaim long-lived objects, a generational GC must collect not only the region of memory holding the object but all younger objects as well; LA collection processes objects of any age independently.We plan to build a novel LA heap structure over our Beltway GC framework. We shall explore the object demographics of realistic Java programs through a combination of off-line analysis of program traces, static analysis of program code and run-time sampling in order to identify suitable policies for LA collection. We shall construct new LA collectors that use these policies to the ends described above; we expect significant improvements over existing systems in both throughput - how fast the program executes - and pause-times - brief intervals during which the progam is interrupted to allow the GC to reclaim unused memory.We shall make our analysis tools and the LA collector framework freely available, e.g. through our website and the UK Memory Management Network (MM-NET). As well as dissemination through the usual vehicles of journals and conferences, a mid-project workshop on analytic support for memory management will be held through the auspices of MM-NET.","grantUrl":"http://gtr.rcuk.ac.uk/projects?ref=EP/D078342/1","grantId":"EP/D078342/1","fundValue":"285743","fundStart":"2006-08-01","fundEnd":"2009-07-31","funder":"EPSRC","impactText":"","person":"Richard Elliott Jones","coPersons":["Andy  King"],"organisation":"University of Kent","findingsText":"","dataset":"gtr"}